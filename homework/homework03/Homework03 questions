1. Binary 10111101 in hex is: 1011 1101 -> 0xBD


2. Binary 1011110100000001 as an unsigned decimal is: 2^0 + 2^8 + 2^10 + 2^11 + 2^12+ 2^13 + 2^15 = 32768 + 8192 + 4096 + 2048 + 1024 + 256 + 1 = 48385


3. Binary 1011110100000001 as a signed decimal is: Number is negative, since first bit is a one. In order to get its proper value, we must flip the bits, then add one. 1011110100000001 flipped is 0100001011111110. When we add 1, it becomes 0100001011111111. We then convert this to decimal, and put a negative sign at the front. 0100001011111111 -> -(2^0 + 2^1 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 + 2^9 + 2^14) = -17151


4. Decimal 8000 encoded in 16-bits (unsigned) is in hex: 8000 is less than 65535, so we know it fits in 16 bits. In order to convert 8000 to hex, we must divide it by 16 until we have our quotient as 0. Doing this gives us 0x1F40.


5. Decimal 8000 encoded in 16-bits (signed) is in hex: Decimal 8000 signed is the same as decimal 8000 un-signed, which is 1F40. This is because 8000 < 32767, which means we can represent it with our number of bits.


6. Decimal -11 encoded in 16-bits (signed) is in hex: In order to convert -11 to signed hex, you must convert the absolute value to binary, invert the bits, add one, then convert. 11 in binary (16-bits) is 0000 0000 0000 1011. We flip the bits, giving us 1111 1111 1111 0100. Then, we add one, giving us 1111 1111 1111 0101. This becomes 0xFFF5 in hex, which is our answer.


7. Decimal -32717 encoded in 16-bits (signed) is in hex: We will follow the same procedure as #6 to solve #7. 32717 in binary is 0111 1111 1100 1101. We then flip the bits, giving us 1000 0000 0011 0010. We add one, giving us 1000 0000 0011 0011. This is then converted to hex, giving us 0x8033.


8. Hex FAC3 in binary is: 

- 15 10 12 3
  which is:

  1111 1010 1100 0011


9. Hex FAC3 as an unsigned decimal is: 64195

- (1 * 2^0) + (1 * 2^1) + (1 * 2^6) + (1 * 2^7) + (1 * 2^9) + (1 * 2^11) + (1 * 2^12) + (1 * 2^13) + (1 * 2^14) + (1 * 2^15) = 64195


10. Hex FAC3 as a signed decimal is: -1341
- Flipped bits: 
  0000 0101 0011 1100
  Plus One: 
  0000 0101 0011 1101
  This in decimal form is: -1341


11. Hex 0064 in binary is: 

- 0000 0000 0110 0100
   0     0    6    4



12. Hex 0064 as an unsigned decimal is: 100

- (1 * 2^2) + (1 * 2^5) + (1 * 2^6) = 100


13. Hex 0064 as a signed decimal is: 100

- MSB is not 1, so it is not a negative signed decimal, therefore we need not perform 2's complement on it


14. Hex 8000 in binary is: 

- 1000 0000 0000 0000
    8   0    0    0



15. Hex 8000 as an unsigned decimal is: 32768
- 8 * 16^3 = 32768


16. Hex 8000 as a signed decimal is:
- (8 x 16^3) + (0 x 16^2) + (0 x 16^1) + (0 x 16^0) = (8 x 4096) + 0 + 0 + 0 = -32768, since bit 15=1 thus its negative

17. If we had 20-bit registers, the smallest signed decimal integer value would be:
- -2^(n-1) = -2^(19) = -524,288

18. If we had 20-bit registers, the largest signed decimal integer value would be:
- 2^(n-1) -1 = 2^19 = 524,288 - 1 = 524,287

19. The modular sum of 16-bit hex values 3511 + 4FFC is:
- 850D

20. The saturated sum of 16-bit hex values 3511 + 4FFC is:
- 34,061

21. The 16-bit operation 0x3511 + 0x4FFC has a carry (Y or N):
- 0x3511 + 0x4FFC = 0x850D = No it doesn't have a carry

22. The 16-bit operation 0x3511 + 0x4FFC has a overflows (Y or N):
- 34,061 > 32,767 = Yes it overflows



------------------------------------------------------------------


23. The modular sum of 16-bit hex values 6159 + F702 is:
- 6159 + F702 = 585B

24. The saturated sum of 16-bit hex values 6159 + F702 is:
- FFFF

25. The 16-bit operation 0x6159 + 0xF702 has a carry (Y or N):
- Yes

26. The 16-bit operation 0x6159 + 0xF702 has a overflows (Y or N):
- Yes

27. The modular sum of 16-bit hex values EEEE + C00C is: 
- 1AEFA


28. The saturated sum of 16-bit hex values EEEE + C00C is: 
- FFFF


29. The 16-bit operation 9EEE + AB0C has a carry (Y or N): 
- Y


30. The 16-bit operation 9EEE + AB0C has a overflows (Y or N): 
- Y


31. The negation of 16-bit word 0xB00F is: 
- 4FF1


32. The negation of 16-bit word 0x2232 is: 
- DDCE


33. The negation of 16-bit word 0x8000 is:
- 0x8000

34. The negation of 32-bit word 0xFFF329BA is:
- 0x000CD646

35. Hex 43700000, when interpreted as an IEEE-754 pattern, is in decimal:
- 240

36. Hex C0FF0000, when interpreted as an IEEE-754 pattern, is in decimal:
- -7.96875

---------------------------------------------------------------------------------

37. 96.03125 as a 32-bit float, in hex is: In order to convert 96.03125 as a 32-bit float to hex, we must use the IEEE-754  format, where the first bit is the sign, the next 8 are the exponent, and the final 23 make up the "mantissa". 
Our number is positive, so our first bit is automatically 0. We then convert 96 to binary, which is 1100000. Then, we multiply the decimal part by two until no decimal remains. So, 0.03125 * 2 = 0.0625 * 2 = 0.125 * 2 = 0.25 * 2 = 0.5 * 2 = 1. We did this 5 times, 
so our decimal becomes .00001. We then combine the 96 and the decimal, giving us 1100000.00001. We need to also shift the decimal point, so we do that to get 1.10000000001 * 2^6. Our sign is a 0 bit, our exponent is 6 + 127 = 133 (10000101). We then pad
our mantissa with bits to the right so it can be 23 bits long. This gives us 10000000001000000000000. Our number in IEEE-754 is thus 0 10000101 10000000001000000000000, which we now convert to hex. 
To make it easier to convert to hex, we split it into 4 bit groups, which gives us 0100 0001 0110 0000 0001 0000 0000 0000. The hex conversion is now straightforward, with it being: 0x41601000.

38. -16777216 as a 32-bit float, in hex is: We must follow the procedures from #37 to solve #38. Our number is negative, so our sign is 1. Luckily, the absolute value of our number expressed as a power of 2 is 2^24. This makes our
conversion much easier, as our mantissa is just 23 bits of 0. Our exponent is then 24 + 127 = 151 (10010111). In binary, our IEEE-754 number is therefore 11001011100000000000000000000000. Separating into 4-bit groups to make
conversion easier gives us 1100 1011 1000 0000 0000 0000 0000 0000. The hex conversion is now straightforward, with it being: 0xCB800000.


39. The largest finite IEEE-754 single precision float, in hex is: 
- 0x7F7FFFFF

  Sign: 0

  Exponent: 254 → 11111110

  Fraction: 23 ones → 11111111111111111111111

  Binary:
  0111 1111 0111 1111 1111 1111 1111 1111
    7    F    7    F    F    F    F    F
  
  

40. The smallest finite IEEE-754 single precision float, in hex is:

- 0x00800000

  Sign = 0
  Exponent = 1 (biased = 1 → actual exponent = −126)
  Fraction = 0



41. The largest nonzero negative IEEE-754 single precision float, in hex is:

- 0xFF7FFFFF

  Sign = 1
  Exponent = 254 (largest before infinity)
  Fraction = all 1s

42. The smallest nonezero positive IEEE-754 single precision float, in hex is:

- 0x00000001

  Sign = 0
  Exponent = 0 (subnormal)
  Fraction = 0…01 (only last fraction bit set)

43. -5.125 X 290 as a 32-bit float, in hex is:
- 0xDB480000

44. 2-138 as a 32-bit float, in hex is:
- 0x00000800

45. 1.5 X 2-143 as a 32-bit float, in hex is:
- 0x00000060

46. Try this for a challenge, a puzzle, or the experience:  Hex C059000000000000, when iterpreted as a 64-bit IEEE-754 pattern, is in decimal:
- -100.0
